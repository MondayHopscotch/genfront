package process

import (
	"bytes"
	"fmt"
	"html/template"
	"io"
	"log"
	"os"
	"strings"

	"github.com/spf13/viper"
)

var EnvVars = []string{
	"GOARCH",
	"GOOS",
	"GOFILE",
	"GOLINE",
	"GOPACKAGE",
	"DOLLAR",
}

type Env struct {
	pairs map[string]interface{}
}

func NewEnv() *Env {
	env := &Env{
		pairs: make(map[string]interface{}),
	}
	env.AddEnv()
	return env
}
func (e *Env) ToMap() map[string]interface{} {
	return e.pairs
}
func (e *Env) Add(key string, val interface{}) *Env {
	e.pairs[key] = val
	return e
}
func (e *Env) AddPairs(pairs map[string]interface{}) *Env {
	for k, v := range pairs {
		e.Add(k, v)
	}
	return e
}
func (env *Env) AddSettings(frontmatter string) (*Env, error) {
	v := viper.New()
	v.SetConfigType("yaml")
	err := v.ReadConfig(bytes.NewBufferString(frontmatter))
	return env, err
}
func (e *Env) Sep() string {
	return strings.Repeat("-", 80)
}

func (env *Env) ShowEnvironment(w io.Writer) {
	for k, v := range env.pairs {
		fmt.Fprintf(w, "%s : %s\n", k, v)
	}
	for i, e := range os.Args {
		fmt.Fprintf(w, "os.Args[%d] = %s\n", i, e)
	}
}

func (env *Env) String(key string) string {
	g, ok := env.pairs[key]
	if !ok {
		return ""
	}
	s, ok := g.(string)
	if ok {
		return s
	} else {
		return ""
	}
}

func (env *Env) AddEnv() *Env {
	for _, e := range EnvVars {
		env.Add(e, os.Getenv(e))
	}

	if p, ok := env.pairs["GOPACKAGE"]; !ok || p == "" {
		env.Add("GOPACKAGE", "main")
	}

	wd, err := os.Getwd()
	if err != nil {
		log.Fatal(err)
	}

	env.Add("CWD", wd)
	env.Add("GEN_TAGLINE", fmt.Sprintf("// Generated by %s -- do not edit this file.", os.Args[0]))
	env.Add("Args", os.Args)

	return env
}

func (env *Env) BuildFuncMap() template.FuncMap {
	return template.FuncMap{
		"title":  toPascal,
		"lower":  strings.ToLower,
		"getenv": os.Getenv,
	}
}

func (env *Env) CreateTemplate(tpl string) (*template.Template, error) {
	return template.New("FrontMatterProcessor").Funcs(env.BuildFuncMap()).Parse(tpl)
}
